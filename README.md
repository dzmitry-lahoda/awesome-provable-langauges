## Can do proofs:
| langauge| wasm target | riskv target | x86 target | arm target | lazy | dependant types | linear types | bootstrapped |  general purpose | refinement types |
| --------| ------------| -------------| -----------| -----------|------|-----------------|--------------| -------------| -----------------| ----------------- |
| agda    |
| lean    |    +        |              | +           |      +    | -    | +               |               |     +       |       +            | |
| dafny   | |             |               |         |          |                    |         |            |       +             ||
| !! [quint](https://quint-lang.org/)   |
| idris |               
| coq| |             |               |         |          |                    |         |            |       -             ||
| fstar |               |             |               |         |          |                    |         |            |       +             ||
| !!alloy |
| !!tlaplus|
| ??[curry](https://curry-lang.org/) |  |             |               |         |          |                    |         |            |       +             ||
| ??[mercury](https://mercurylang.org/) | 
| [isabelle](https://isabelle.in.tum.de/)
## Strong safe type systems which cannot do full proofs in language (can use industially accepted extensions/analyzers/plugins within some limits):
- haskell
- [rust](https://github.com/newca12/awesome-rust-formalized-reasoning?tab=readme-ov-file#verification) 

## Prolog?

Not sure if prolog fits, so add langauges which is superset ?? of prolog.

## Model checkers and specification lanagues ?

!!

## Sumpbolic like Mathematica?

## Prominent projects

### Lean

Alfa fold


## Other lists

https://github.com/awesomo4000/awesome-provable?tab=readme-ov-file#languages
